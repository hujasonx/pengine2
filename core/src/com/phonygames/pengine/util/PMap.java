package com.phonygames.pengine.util;

import com.badlogic.gdx.utils.ArrayMap;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.Pool;
import com.phonygames.pengine.exception.PAssert;
import com.phonygames.pengine.logging.PLog;

import java.util.Iterator;

import lombok.Getter;
import lombok.NonNull;
import lombok.val;

/**
 * List class whose iterator() does not allocate.
 */
public class PMap<K, V> implements Iterable<PMap.Entry<K, V>>, PCopyable<PMap<K, V>>, Pool.Poolable {
  private final PPool<PMapIterator<K, V>> iteratorPool = new PPool<PMapIterator<K, V>>() {
    @Override
    protected PMapIterator<K, V> newObject() {
      return new PMapIterator<>(this);
    }
  };

  public static class PMapIterator<K, V> implements Iterator<Entry<K, V>>, Pool.Poolable {
    private final PPool<PMapIterator<K, V>> iteratorPool;
    private final PMap.Entry<K, V> entry = new PMap.Entry<>();
    private MapInterface<K, V> mapInterface;
    private Iterator backingIterator;
    private int index;

    private PMapIterator(@NonNull PPool<PMapIterator<K, V>> iteratorPool) {
      this.iteratorPool = iteratorPool;
    }

    @Override
    public boolean hasNext() {
      if (backingIterator == null) {
        return false;
      }

      boolean hasNext = backingIterator.hasNext();
      if (!hasNext) {
        iteratorPool.free(this);
      }
      return hasNext;
    }

    @Override
    public Entry<K, V> next() {
      PAssert.isNotNull(backingIterator);
      PAssert.isNotNull(mapInterface);
      Object o = backingIterator.next();
      entry.index = mapInterface.isStableOrdered() ? index : -1;
      entry.k = mapInterface.getIteratorKey(o);
      entry.v = mapInterface.getIteratorVal(o);

      index++;
      return entry;
    }

    @Override
    public void reset() {
      index = 0;
      backingIterator = null;
      mapInterface = null;
    }
  }

  @Override
  public final PMapIterator<K, V> iterator() {
    val it = iteratorPool.obtain();
    it.mapInterface = mapInterface;
    it.backingIterator = mapInterface.iterator();
    return it;
  }

  protected static abstract class MapInterface<K, V> implements Iterable {

    abstract V get(K k);

    abstract V put(K k, V v);

    abstract V del(K k);

    abstract void clear();

    abstract int size();

    abstract boolean isStableOrdered();

    abstract K getIteratorKey(Object mapEntry);

    abstract V getIteratorVal(Object mapEntry);
  }

  private static final class ArrayMapInterface<K, V> extends MapInterface<K, V> {
    private final ArrayMap<K, V> backingMap = new ArrayMap<>();

    @Override
    V get(K k) {
      return backingMap.get(k);
    }

    @Override
    V put(K k, V v) {
      V ret = backingMap.get(k);
      backingMap.put(k, v);
      return ret;
    }

    @Override
    V del(K k) {
      V ret = backingMap.removeKey(k);
      return ret;
    }

    @Override
    void clear() {
      backingMap.clear();
    }

    @Override
    int size() {
      return backingMap.size;
    }

    @Override
    boolean isStableOrdered() {
      return true;
    }

    @Override
    public Iterator iterator() {
      return backingMap.iterator();
    }

    @Override
    K getIteratorKey(Object mapEntry) {
      return ((ObjectMap.Entry<K, V>) mapEntry).key;
    }

    @Override
    V getIteratorVal(Object mapEntry) {
      return ((ObjectMap.Entry<K, V>) mapEntry).value;
    }
  }

  public static class Entry<K, V> {
    private K k;
    private V v;
    private int index = -1;

    public K k() {
      return k;
    }

    public V v() {
      return v;
    }

    public int index() {
      PAssert.isFalse(index == -1, "PMap.Entry.index() was called but index was not set");
      return index;
    }
  }


  private final MapInterface<K, V> mapInterface;
  @Getter(lazy = true)
  private final PPool<V> genedValuesPool = new PPool<V>() {
    @Override
    protected V newObject() {
      return newPooled();
    }
  };
  @Getter(lazy = true)
  private final PList<V> genedValuesUsed = new PList<>();

  public PMap() {
    mapInterface = new ArrayMapInterface<>();
  }

  public PMap(MapInterface<K, V> mapInterface) {
    this.mapInterface = mapInterface;
  }

  @Override
  public final PMap<K, V> copyFrom(PMap<K, V> other) {
    for (val e : other) {
      put(deepCopyKey(e.k), deepCopyValue(e.v));
    }

    return this;
  }

  // Can be overridden to help with deep copies.
  public K deepCopyKey(K k) {
    PAssert.failNotImplemented("deepCopyKey");
    return null;
  }

  // Can be overridden to help with deep copies.
  public V deepCopyValue(V v) {
    PAssert.failNotImplemented("deepCopyValue");
    return null;
  }

  /**
   * Returns if the value was generated by this map AND should be expected to be pooled when cleared.
   *
   * @param v
   * @return if the value is pooled by this map
   */
  public final boolean owns(V v) {
    return getGenedValuesUsed() != null && getGenedValuesUsed().contains(v, true);
  }

  /**
   * @param k
   * @return
   */
  public final V genPooled(@NonNull K k) {
    V v = get(k);
    if (v != null) {
      return v;
    }

    v = getGenedValuesPool().obtain();
    getGenedValuesUsed().add(v);
    mapInterface.put(k, v);

    return v;
  }

  /**
   * Caller is responsible for dealing with the results of the allocation.
   *
   * @param k
   * @return
   */
  public final V genUnpooled(@NonNull K k) {
    V v = get(k);
    if (v != null) {
      return v;
    }

    // Generate the result into the object setter.
    v = newUnpooled(k);
    mapInterface.put(k, v);

    return v;
  }

  private final void freeIfManaged(@NonNull V v) {
    if (genedValuesUsed != null) {
      int indexOfV = getGenedValuesUsed().indexOf(v, true);
      if (indexOfV != -1) {
        getGenedValuesPool().free(v);
        getGenedValuesUsed().removeIndex(indexOfV);
      }
    }
  }

  /**
   * @param k
   * @param v
   * @return the previously existing value at the key.
   */
  public final V put(@NonNull K k, @NonNull V v) {
    V alreadyThere = mapInterface.get(k);
    if (alreadyThere != null) {
      if (alreadyThere == v) {
        return v;
      } else {
        freeIfManaged(alreadyThere);
      }
    }

    return mapInterface.put(k, v);
  }

  public V get(@NonNull K k) {
    return mapInterface.get(k);
  }

  public final boolean has(@NonNull K k) {
    return mapInterface.get(k) != null;
  }

  public final V del(@NonNull K k) {
    V v = mapInterface.del(k);
    if (v != null) {
      freeIfManaged(v);
    }

    return v;
  }

  /**
   * Override this to generate values.
   *
   * @return the new object
   */
  protected V newPooled() {
    PAssert.failNotImplemented("newPooledObject");
    return null;
  }

  /**
   * Override this to generate values with keys.
   *
   * @param k key to generate using
   * @return the new object
   */
  protected V newUnpooled(K k) {
    PAssert.failNotImplemented("newUnpooledObject");
    return null;
  }

  public void clear() {
    if (getGenedValuesUsed().size > 0) {
      PAssert.isTrue(getGenedValuesUsed().size == mapInterface.size(),
                     "Don't call clear() on a map with mixed pooled / unpooled objects!");
      getGenedValuesPool().freeAll(getGenedValuesUsed());
      getGenedValuesUsed().clear();
    }

    mapInterface.clear();
  }

  public final void putAll(@NonNull Iterable<Entry<K, V>> other) {
    for (val e : other) {
      put(e.k(), e.v());
    }
  }

  public final void delAll(@NonNull Iterable<K> keys) {
    for (K k : keys) {
      del(k);
    }
  }

  @Getter(lazy = true)
  private final PList<K> keysToKeep = new PList<>();
  @Getter(lazy = true)
  private final PList<V> valuesToKeep = new PList<>();

  /**
   * Clears the contents of the map. If removeMaps is set, then maps will be removed too
   * (they probably were not pooled, so use wisely!)
   *
   * @param removeMapsIfUnpooled
   */
  public final void clearRecursive(boolean removeMapsIfUnpooled) {
    // Iterate through children, and keep maps if they should be kept.
    int numKeysToKeep = 0;
    for (val e : this) {
      if (e.v() instanceof PMap) {
        val map = (PMap) e.v();
        map.clearRecursive(removeMapsIfUnpooled);
        if (!removeMapsIfUnpooled) {

          if (getGenedValuesUsed().contains(e.v(), true)) {
            // Pooled, so clear anyways.
          } else {
            // Unpooled.
            getKeysToKeep().add(e.k());
            getValuesToKeep().add(e.v());
            numKeysToKeep++;
          }
        } else {
          PLog.w("Removing maps may cause allocs");
        }
      }
    }

    // Clear the map, and re-add things to keep.
    mapInterface.clear();
    if (numKeysToKeep > 0) {
      for (int a = 0; a < getKeysToKeep().size; a++) {
        mapInterface.put(getKeysToKeep().get(a), getValuesToKeep().get(a));

        // Pooled objects should still be tracked as pooled.
        if (getGenedValuesUsed() != null) {
          getGenedValuesUsed().removeValue(getValuesToKeep().get(a), true);
        }
      }


      getKeysToKeep().clear();
      getValuesToKeep().clear();
    }

    getGenedValuesPool().freeAll(getGenedValuesUsed());
    getGenedValuesUsed().clear();
  }

  @Override
  public void reset() {
    clearRecursive(true);
  }
}