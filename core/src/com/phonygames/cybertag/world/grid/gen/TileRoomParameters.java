package com.phonygames.cybertag.world.grid.gen;

import com.phonygames.cybertag.world.grid.GridTile;
import com.phonygames.cybertag.world.grid.TileRoom;
import com.phonygames.pengine.exception.PAssert;
import com.phonygames.pengine.util.PFacing;
import com.phonygames.pengine.util.collection.PIntMap3d;
import com.phonygames.pengine.util.collection.PList;
import com.phonygames.pengine.util.collection.PPooledIterable;

/** The parameters that a TileRoom may be generated by. */
public abstract class TileRoomParameters {
  /**
   * The weights for possible door widths. If two rooms with different weights have a door generated, the door width
   * will be chosen using the sum of the weights, with the max door width being the minimum of the maxima of the door
   * widths for the rooms.
   */
  public float[] doorWidthWeights = new float[]{0.5f, .4f, .3f, .2f, .1f};
  /** The weights for the room height in tiles. */
  public float[] heightWeights = new float[]{0.5f, .4f, .3f, .2f, .1f};
  /** Whether or not the room should be counted as a hallway. */
  public boolean isHallway = false;
  /** The maximum number of tiles in a horizontal edge. */
  public int maximumEdgeSize = 10;
  /** The minimum number of tiles in a horizontal edge. */
  public int minimumEdgeSize = 5;
  /** The ratio of floor tiles that must have full height (no obstructions from other rooms. */
  public float minimumFullHeightTilesRatio = .25f;
  /** The minimum horizontal thickness of any given portion of the room. */
  public int minimumRoomThickness = 3;
  /** The ratio of tiles that must be in the room compared to the constructed bounds. */
  public float minimumTilesRatio = .5f;
  /** Whether or not the room should have an open ceiling. */
  public boolean openCeiling = false;

  /**
   * Sets the possible door locations. The rooms will already be laid out at this point (but not hallways). This method
   * should set the parameters in the GridTile.EmitOptions directly.
   */
  public abstract void emitPossibleDoorLocations(TileRoom room);
  /** Processes the room after doors are generated. This gets run before processTileOptionsAfterDoorsGenned. */
  public abstract void processRoomAfterDoorsGenned(TileRoom room);
  /** Processes the tile options for the room and tile. This is done after doors are generated. */
  public abstract void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile);

  /** Reference implementation for hallways. The shape and walkways should be created by TileBuildingGen. */
  public static class HallwayParameters extends TileRoomParameters {
//    /** Stores a working list of walls that can have doors (emitted by emitPossibleDoorLocations) */
//    private final PList<GridTile.EmitOptions.Wall> __wallsThatCanHaveDoors = new PList<>();

    public HallwayParameters() {
      /** Hallways can only have doors of width 1. */
      this.doorWidthWeights = new float[] {1};
      this.isHallway = true;
    }

    /**
     * This will be run many times by TileBuildingGen, so it may edit wall doorPlacementScores multiple times! This is
     * because doorPlacementScore will be used to combine hallway rooms.
     */
    @Override public void emitPossibleDoorLocations(TileRoom room) {
      /**
       * Actually, this is a noop. Doors should be explicitly generated by TileBuildingGen.
       *
       */
    }

    @Override public void processRoomAfterDoorsGenned(TileRoom room) {
      // TODO: Add decorations. Walkways should not be added here for hallways!
    }

    /** Returns the walkway template id for a traversed tile. */
    public String walkwayTemplateForTraversedTile(TileRoom room, GridTile tile) {
      return "model/template/floor/basic.glb";
    }

    /** Returns the ceiling template id for a traversed tile. */
    public String ceilingTemplateForTraversedTile(TileRoom room, GridTile tile) {
      return "model/template/floor/basic.glb";
    }

    /** Returns the wall template for the given internal wall. */
    public void addWallTemplatesFor(TileRoom room, GridTile tile, GridTile.EmitOptions.Wall wall) {
      if (wall.door != null) {
        return;
      }
      wall.wallModelTemplateIDs.add("model/template/wall/basic.glb");
    }

    @Override public void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile) {
    }
  }

  /** Reference implementation. */
  public static class Standard extends TileRoomParameters {
    @Override public void emitPossibleDoorLocations(TileRoom room) {
      // Loop through all tiles and simply say that all tile walls that are on the edge can have doors. This is just
      // the most basic case.
      try (PPooledIterable.PPoolableIterator<PIntMap3d.Entry<GridTile>> it = room.tileGrid().obtainIterator()) {
        while (it.hasNext()) {
          PIntMap3d.Entry<GridTile> e = it.next();
          GridTile tile = e.val();
          for (int a = 0; a < PFacing.count(); a++) {
            GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
            if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
              wall.doorPlacementScore = 1;
            }
          }
        }
      }
    }

    @Override public void processRoomAfterDoorsGenned(TileRoom room) {
      // TODO: Add walkways and decorations.
    }

    @Override public void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile) {
      // Set the floor to a basic floor if it is at the bottom of the room.
      if (!room.tileGrid().hasTileAt(tile.x, tile.y - 1, tile.z)) {
        tile.emitOptions.floorModelTemplateID = "model/template/floor/basic.glb";
      }
//      if (Math.random() < .15) {
//        tile.emitOptions.walkwayModelTemplateID = "model/template/floor/basic.glb";
//        tile.emitOptions.walkwayCornerVerticalOffsets[0] = 0; // 00;
//        tile.emitOptions.walkwayCornerVerticalOffsets[1] = 0; // 10;
//        tile.emitOptions.walkwayCornerVerticalOffsets[2] = 1; // 11;
//        tile.emitOptions.walkwayCornerVerticalOffsets[3] = 1; // 01;
//      }
      for (int a = 0; a < PFacing.count(); a++) {
        GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
        if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
          if (!room.building()
                   .tilePositionInBuilding(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
            // If the room is at the edge of the building, emit a window instead.
            wall.wallModelTemplateIDs.add("model/template/window/basic.glb");
          } else if (wall.door != null) {
            // TODO: Emit a door.
          } else {
            wall.wallModelTemplateIDs.add("model/template/wall/basic.glb");
          }
        }
      }
    }
  }
  //  public void
}
