package com.phonygames.cybertag.world.grid.gen;

import com.phonygames.cybertag.world.grid.GridTile;
import com.phonygames.cybertag.world.grid.TileGrid;
import com.phonygames.cybertag.world.grid.TileRoom;
import com.phonygames.pengine.math.PInt3;
import com.phonygames.pengine.util.Duple;
import com.phonygames.pengine.util.PFacing;
import com.phonygames.pengine.util.collection.PIntMap3d;
import com.phonygames.pengine.util.collection.PList;
import com.phonygames.pengine.util.collection.PPooledIterable;

/** The parameters that a TileRoom may be generated by. */
public abstract class TileRoomParameters {
  /** The maximum number of tiles in a horizontal edge. */
  public int maximumEdgeSize = 10;
  /** The minimum number of tiles in a horizontal edge. */
  public int minimumEdgeSize = 5;
  /** The weights for the room height in tiles. */
  public float[] heightWeights = new float[] {0.5f, .4f, .3f, .2f, .1f};
  /** The minimum horizontal thickness of any given portion of the room. */
  public int minimumRoomThickness = 3;
  /** The ratio of floor tiles that must have full height (no obstructions from other rooms. */
  public float minimumFullHeightTilesRatio = .25f;
  /** The ratio of tiles that must be in the room compared to the constructed bounds. */
  public float minimumTilesRatio = .5f;
  /** Whether or not the room should have an open ceiling. */
  public boolean openCeiling = false;

  public static class Standard extends TileRoomParameters {
    @Override public void emitPossibleDoorLocations(TileRoom room) {
      // Loop through all tiles and simply say that all tile walls that are on the edge can have doors. This is just
      // the most basic case.
      try (PPooledIterable.PPoolableIterator<PIntMap3d.Entry<GridTile>> it = room.tileGrid().obtainIterator()) {
        while (it.hasNext()) {
          PIntMap3d.Entry<GridTile> e = it.next();
          GridTile tile = e.val();
          for (int a = 0; a < PFacing.count(); a++) {
            GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
            if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
              wall.validDoorPlacement = true;
            }
          }
        }
      }
    }

    @Override public void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile) {
      // Set the floor to a basic floor if it is at the bottom of the room.
      if (!room.tileGrid().hasTileAt(tile.x, tile.y - 1, tile.z)) {
        tile.emitOptions.floorModelTemplateID = "model/template/floor/basic.glb";
      }

      if (Math.random() < .15) {
        tile.emitOptions.walkwayModelTemplateID = "model/template/floor/basic.glb";
        tile.emitOptions.walkwayCornerVerticalOffsets[0] = 0; // 00;
        tile.emitOptions.walkwayCornerVerticalOffsets[1] = 0; // 10;
        tile.emitOptions.walkwayCornerVerticalOffsets[2] = 1; // 11;
        tile.emitOptions.walkwayCornerVerticalOffsets[3] = 1; // 01;
      }

      for (int a = 0; a < PFacing.count(); a++) {
        GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
        if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
          if (!room.building().tilePositionInBuilding(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
            // If the room is at the edge of the building, emit a window instead.
            wall.wallModelTemplateID = "model/template/window/basic.glb";
          } else {
            wall.wallModelTemplateID = "model/template/wall/basic.glb";
          }
        }

      }
    }

    @Override public void processRoomAfterDoorsGenned(TileRoom room) {
      // TODO: Add walkways and decorations.
    }
  }

  /** Sets the possible door locations. The rooms will already be laid out at this point (but not hallways). This method should set the parameters in the GridTile.EmitOptions directly. */
  public abstract void emitPossibleDoorLocations(TileRoom room);

  /** Processes the tile options for the room and tile. This is done after doors are generated. */
  public abstract void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile);

  /** Processes the room after doors are generated. This gets run before processTileOptionsAfterDoorsGenned. */
  public abstract void processRoomAfterDoorsGenned(TileRoom room);

//  public void
}
