package com.phonygames.cybertag.world.grid.gen;

import com.phonygames.cybertag.world.grid.GridTile;
import com.phonygames.cybertag.world.grid.TileRoom;
import com.phonygames.pengine.util.PFacing;
import com.phonygames.pengine.util.collection.PIntMap3d;
import com.phonygames.pengine.util.collection.PList;
import com.phonygames.pengine.util.collection.PPooledIterable;

/** The parameters that a TileRoom may be generated by. */
public abstract class TileRoomParameters {
  /**
   * The weights for possible door widths. If two rooms with different weights have a door generated, the door width
   * will be chosen using the sum of the weights, with the max door width being the minimum of the maxima of the door
   * widths for the rooms.
   */
  public float[] doorWidthWeights = new float[]{0.5f, .4f, .3f, .2f, .1f};
  /** The weights for the room height in tiles. */
  public float[] heightWeights = new float[]{0.5f, .4f, .3f, .2f, .1f};
  /** Whether or not the room should be counted as a hallway. */
  public boolean isHallway = false;
  /** The maximum number of tiles in a horizontal edge. */
  public int maximumEdgeSize = 10;
  /** The minimum number of tiles in a horizontal edge. */
  public int minimumEdgeSize = 5;
  /** The ratio of floor tiles that must have full height (no obstructions from other rooms. */
  public float minimumFullHeightTilesRatio = .25f;
  /** The minimum horizontal thickness of any given portion of the room. */
  public int minimumRoomThickness = 3;
  /** The ratio of tiles that must be in the room compared to the constructed bounds. */
  public float minimumTilesRatio = .5f;
  /** Whether or not the room should have an open ceiling. */
  public boolean openCeiling = false;

  /**
   * Sets the possible door locations. The rooms will already be laid out at this point (but not hallways). This method
   * should set the parameters in the GridTile.EmitOptions directly.
   */
  public abstract void emitPossibleDoorLocations(TileRoom room);
  /** Processes the room after doors are generated. This gets run before processTileOptionsAfterDoorsGenned. */
  public abstract void processRoomAfterDoorsGenned(TileRoom room);
  /** Processes the tile options for the room and tile. This is done after doors are generated. */
  public abstract void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile);

  /** Reference implementation for hallways. The shape and walkways should be created by TileBuildingGen. */
  public static class HallwayParameters extends TileRoomParameters {
//    /** Stores a working list of walls that can have doors (emitted by emitPossibleDoorLocations) */
//    private final PList<GridTile.EmitOptions.Wall> __wallsThatCanHaveDoors = new PList<>();

    public HallwayParameters() {
      /** Hallways can only have doors of width 1. */
      this.doorWidthWeights = new float[] {1};
      this.isHallway = true;
    }

    /**
     * This will be run many times by TileBuildingGen, so it may edit wall doorPlacementScores multiple times! This is
     * because doorPlacementScore will be used to combine hallway rooms.
     */
    @Override public void emitPossibleDoorLocations(TileRoom room) {
      //      // Loop through all tiles and walls and say that any spots that don't have a walkway in front can have
      //      doors.
      //      try (PPooledIterable.PPoolableIterator<PIntMap3d.Entry<GridTile>> it = room.tileGrid().obtainIterator()) {
      //        // Holding array for the current working value for door status, one for each facing.
      //        boolean[] canEmitDoorAt = new boolean[4];
      //        while (it.hasNext()) {
      //          Arrays.fill(canEmitDoorAt, false);
      //          PIntMap3d.Entry<GridTile> e = it.next();
      //          GridTile tile = e.val();
      //          if (tile.emitOptions.walkwayModelTemplateID == null) {
      //            // If there is no walkway at this tile, it either must have have a floor or a walkway below it.
      //            if (tile.emitOptions.floorModelTemplateID != null) {
      //              Arrays.fill(canEmitDoorAt, true);
      //            } else {
      //              // The tile below must be part of this room and have a walkway.
      //              GridTile tileBelow = room.tileGrid().getTileAt(tile.x, tile.y - 1, tile.z);
      //              if (tileBelow == null || tileBelow.emitOptions.walkwayModelTemplateID == null) {
      //                // Bust; this tile can't have a floor anywhere.
      //              } else {
      //                // Check if there is a walkway that reaches any edges on the tile below.
      //                if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[0] == 1) { // 00 is at top.
      //                  if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[1] == 1) { // 10 is at top.
      //                    canEmitDoorAt[PFacing.mZ.intValue()] = true;
      //                  }
      //                  if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[3] == 1) { // 01 is at top.
      //                    canEmitDoorAt[PFacing.mX.intValue()] = true;
      //                  }
      //                }
      //                if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[0] == 1) { // 11 is at top.
      //                  if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[1] == 1) { // 10 is at top.
      //                    canEmitDoorAt[PFacing.X.intValue()] = true;
      //                  }
      //                  if (tileBelow.emitOptions.walkwayCornerVerticalOffsets[3] == 1) { // 01 is at top.
      //                    canEmitDoorAt[PFacing.Z.intValue()] = true;
      //                  }
      //                }
      //              }
      //            }
      //          } else { // Tile has a walkway.
      //            // If the tile has a walkway, the walkway must be pointing directly at the ground..
      //            // Check if there is a walkway that reaches any edges.
      //            if (tile.emitOptions.walkwayCornerVerticalOffsets[0] == 0) { // 00 is at bottom.
      //              if (tile.emitOptions.walkwayCornerVerticalOffsets[1] == 0) { // 10 is at bottom.
      //                canEmitDoorAt[PFacing.mZ.intValue()] = true;
      //              }
      //              if (tile.emitOptions.walkwayCornerVerticalOffsets[3] == 0) { // 01 is at bottom.
      //                canEmitDoorAt[PFacing.mX.intValue()] = true;
      //              }
      //            }
      //            if (tile.emitOptions.walkwayCornerVerticalOffsets[0] == 0) { // 11 is at bottom.
      //              if (tile.emitOptions.walkwayCornerVerticalOffsets[1] == 0) { // 10 is at bottom.
      //                canEmitDoorAt[PFacing.X.intValue()] = true;
      //              }
      //              if (tile.emitOptions.walkwayCornerVerticalOffsets[3] == 0) { // 01 is at bottom.
      //                canEmitDoorAt[PFacing.Z.intValue()] = true;
      //              }
      //            }
      //          }
      //          // Check the possible walls and set the door placement score if it is at the edge of the room.
      //          for (int a = 0; a < PFacing.count(); a++) {
      //            GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
      //            wall.doorPlacementScore = 0;
      //            if (!canEmitDoorAt[a]) {continue;}
      //            if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing
      //            .forwardZ())) {
      //              wall.doorPlacementScore = 1;
      //            }
      //          }
      //        }
      //      }
      /**
       * Actually, this is a noop. Doors should be explicitly generated by TileBuildingGen.
       *
       */
      //      for (int a = 0; a < __wallsThatCanHaveDoors.size(); a++) {
//        GridTile.EmitOptions.Wall wall = __wallsThatCanHaveDoors.get(a);
//        GridTile otherTileInRoom = wall.tileOnOtherSideIn(room.tileGrid());
//        if (otherTileInRoom == null) {
//          wall.doorPlacementScore = 1;
//        }
//
//      }
    }

    @Override public void processRoomAfterDoorsGenned(TileRoom room) {
      // TODO: Add decorations. Walkways should not be added here for hallways!
    }

    /** Returns the walkway template id for a traversed tile. */
    public String walkwayTemplateForTraversedTile(TileRoom room, GridTile tile) {
      return "model/template/floor/basic.glb";
    }

    /** Returns the wall template for the given internal wall. */
    public void addWallTemplatesFor(TileRoom room, GridTile tile, GridTile.EmitOptions.Wall wall) {
      if (wall.door != null) {
        return;
      }
      wall.wallModelTemplateIDs.add("model/template/wall/basic.glb");
    }

    @Override public void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile) {
//      // Set the floor to a basic floor if it is at the bottom of the room.
//      if (!room.tileGrid().hasTileAt(tile.x, tile.y - 1, tile.z)) {
//        tile.emitOptions.floorModelTemplateID = "model/template/floor/basic.glb";
//      }
//      if (Math.random() < .15) {
//        tile.emitOptions.walkwayModelTemplateID = "model/template/floor/basic.glb";
//        tile.emitOptions.walkwayCornerVerticalOffsets[0] = 0; // 00;
//        tile.emitOptions.walkwayCornerVerticalOffsets[1] = 0; // 10;
//        tile.emitOptions.walkwayCornerVerticalOffsets[2] = 1; // 11;
//        tile.emitOptions.walkwayCornerVerticalOffsets[3] = 1; // 01;
//      }
//      for (int a = 0; a < PFacing.count(); a++) {
//        GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
//        if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
//          if (!room.building()
//                   .tilePositionInBuilding(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
//            // If the room is at the edge of the building, emit a window instead.
//            wall.wallModelTemplateIDs.add("model/template/window/basic.glb");
//          } else if (wall.door != null) {
//            // TODO: Emit a door.
//          } else {
//            wall.wallModelTemplateIDs.add("model/template/wall/basic.glb");
//          }
//        }
//      }
    }
//
//    /** Tracks a wall as being a possible door location, if the other side is not in this room. */
//    public HallwayParameters trackPossibleDoorWall(GridTile.EmitOptions.Wall wall) {
//      __wallsThatCanHaveDoors.addIfNotPresent(wall, true);
//      return this;
//    }
  }

  /** Reference implementation. */
  public static class Standard extends TileRoomParameters {
    @Override public void emitPossibleDoorLocations(TileRoom room) {
      // Loop through all tiles and simply say that all tile walls that are on the edge can have doors. This is just
      // the most basic case.
      try (PPooledIterable.PPoolableIterator<PIntMap3d.Entry<GridTile>> it = room.tileGrid().obtainIterator()) {
        while (it.hasNext()) {
          PIntMap3d.Entry<GridTile> e = it.next();
          GridTile tile = e.val();
          for (int a = 0; a < PFacing.count(); a++) {
            GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
            if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
              wall.doorPlacementScore = 1;
            }
          }
        }
      }
    }

    @Override public void processRoomAfterDoorsGenned(TileRoom room) {
      // TODO: Add walkways and decorations.
    }

    @Override public void processTileOptionsAfterDoorsGenned(TileRoom room, GridTile tile) {
      // Set the floor to a basic floor if it is at the bottom of the room.
      if (!room.tileGrid().hasTileAt(tile.x, tile.y - 1, tile.z)) {
        tile.emitOptions.floorModelTemplateID = "model/template/floor/basic.glb";
      }
      if (Math.random() < .15) {
        tile.emitOptions.walkwayModelTemplateID = "model/template/floor/basic.glb";
        tile.emitOptions.walkwayCornerVerticalOffsets[0] = 0; // 00;
        tile.emitOptions.walkwayCornerVerticalOffsets[1] = 0; // 10;
        tile.emitOptions.walkwayCornerVerticalOffsets[2] = 1; // 11;
        tile.emitOptions.walkwayCornerVerticalOffsets[3] = 1; // 01;
      }
      for (int a = 0; a < PFacing.count(); a++) {
        GridTile.EmitOptions.Wall wall = tile.emitOptions.walls[a];
        if (!room.tileGrid().hasTileAt(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
          if (!room.building()
                   .tilePositionInBuilding(tile.x + wall.facing.forwardX(), tile.y, tile.z + wall.facing.forwardZ())) {
            // If the room is at the edge of the building, emit a window instead.
            wall.wallModelTemplateIDs.add("model/template/window/basic.glb");
          } else if (wall.door != null) {
            // TODO: Emit a door.
          } else {
            wall.wallModelTemplateIDs.add("model/template/wall/basic.glb");
          }
        }
      }
    }
  }
  //  public void
}
